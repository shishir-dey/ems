name: CD

on:
  push:
    branches: [ "main" ]
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

jobs:
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Configure git for submodules
      run: |
        git config --global url."https://${{ secrets.PAT_TOKEN }}@github.com/".insteadOf "https://github.com/"
        git submodule update --init --recursive
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PAT_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/ems:latest
          ${{ secrets.DOCKER_USERNAME }}/ems:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.DO_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.DO_SERVER_IP }} >> ~/.ssh/known_hosts
    
    - name: Create server backup
      run: |
        ssh root@${{ secrets.DO_SERVER_IP }} '
          if [ -d /var/www/ems ]; then
            cp -r /var/www/ems /var/www/ems.backup.$(date +%Y%m%d_%H%M%S)
            cd /var/www && ls -t ems.backup.* | tail -n +4 | xargs -r rm -rf
          fi
        '
    
    - name: Deploy configuration files
      run: |
        rsync -avz packages/ems-docker/docker-compose.yml root@${{ secrets.DO_SERVER_IP }}:/var/www/ems/
        rsync -avz packages/ems-nginx/ root@${{ secrets.DO_SERVER_IP }}:/var/www/ems/nginx/
        rsync -avz config.env.example root@${{ secrets.DO_SERVER_IP }}:/var/www/ems/
    
    - name: Deploy to server
      env:
        DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/ems:latest
        SERVER_IP: ${{ secrets.DO_SERVER_IP }}
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      run: |
        cat > deploy-script.sh << 'SCRIPT_EOF'
        cd /var/www/ems
        
        # Install Docker and Docker Compose if not present
        if ! command -v docker &> /dev/null; then
          echo "Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sh get-docker.sh
          systemctl enable docker
          systemctl start docker
        fi
        
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
        fi
        
        # Create production environment file from template with actual values
        echo "Creating production environment file from config.env.example..."
        cp config.env.example .env
        
        # Replace placeholder values with actual secrets
        sed -i "s|postgresql://postgres:your-password@db.your-project.supabase.co:5432/postgres?sslmode=require|$DATABASE_URL|g" .env
        sed -i "s|https://your-project.supabase.co|$SUPABASE_URL|g" .env
        sed -i "s|your-anon-key-here|$SUPABASE_ANON_KEY|g" .env
        sed -i "s|your-service-role-key-here|$SUPABASE_SERVICE_ROLE_KEY|g" .env
        sed -i "s|your-super-secret-jwt-key-here|$JWT_SECRET|g" .env
        
        # Update environment to production
        sed -i "s|ENVIRONMENT=development|ENVIRONMENT=production|g" .env
        
        # Update URLs to use server IP instead of localhost
        # In production, frontend is served by the Rust server (no separate frontend port)
        sed -i "s|http://localhost:3001|http://$SERVER_IP|g" .env
        sed -i "s|http://localhost:5002|http://$SERVER_IP|g" .env
        sed -i "s|http://localhost:3001,http://localhost:3000|http://$SERVER_IP|g" .env
        
        # Uncomment production settings
        sed -i "s|# ENVIRONMENT=production|ENVIRONMENT=production|g" .env
        sed -i "s|# RUST_LOG=warn|RUST_LOG=info|g" .env
        sed -i "s|# DEBUG=false|DEBUG=false|g" .env
        
        echo "Production .env file created successfully from config.env.example"
        
        # Update docker-compose.yml with the correct image name
        sed -i "s|\${DOCKER_USERNAME}/ems:latest|$DOCKER_IMAGE|g" docker-compose.yml
        echo "Docker Compose configuration updated with image: $DOCKER_IMAGE"
        
        # Copy nginx configuration from repository
        if [ -f nginx/nginx.conf ]; then
          cp nginx/nginx.conf nginx.conf
          echo "Nginx configuration copied from repository"
        else
          echo "Warning: nginx/nginx.conf not found in repository"
        fi
        
        # Pull latest image and deploy
        echo "Pulling latest Docker image..."
        docker pull $DOCKER_IMAGE
        
        # Stop existing containers
        docker-compose down || true
        
        # Start new containers
        echo "Starting new containers..."
        docker-compose up -d
        
        # Wait for health check
        echo "Waiting for application to be healthy..."
        for i in {1..30}; do
          if docker-compose ps | grep -q "healthy"; then
            echo "Application is healthy!"
            break
          fi
          echo "Waiting for health check... ($i/30)"
          sleep 10
        done
        
        # Clean up old images
        docker image prune -f
        
        echo "Deployment completed successfully!"
        SCRIPT_EOF
        
        # Execute the script on the server
        scp deploy-script.sh root@${SERVER_IP}:/tmp/deploy-script.sh
        ssh root@${SERVER_IP} "chmod +x /tmp/deploy-script.sh && DOCKER_IMAGE='${DOCKER_IMAGE}' SERVER_IP='${SERVER_IP}' DATABASE_URL='${DATABASE_URL}' JWT_SECRET='${JWT_SECRET}' SUPABASE_URL='${SUPABASE_URL}' SUPABASE_ANON_KEY='${SUPABASE_ANON_KEY}' SUPABASE_SERVICE_ROLE_KEY='${SUPABASE_SERVICE_ROLE_KEY}' /tmp/deploy-script.sh && rm /tmp/deploy-script.sh"
        rm deploy-script.sh
    
    - name: Verify deployment
      run: |
        sleep 10
        if curl -f http://${{ secrets.DO_SERVER_IP }}/health; then
          echo "Deployment verified successfully - Application is responding"
        else
          echo "Deployment verification failed - Application not responding"
          ssh root@${{ secrets.DO_SERVER_IP }} "cd /var/www/ems && docker-compose logs --tail=50"
          exit 1
        fi
    
    - name: Cleanup
      run: rm -f ~/.ssh/id_rsa
    
    - name: Deployment summary
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Docker image built and pushed" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Application deployed to Digital Ocean" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Health check passed" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸŒ Application URL: http://${{ secrets.DO_SERVER_IP }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ³ Docker image: ${{ secrets.DOCKER_USERNAME }}/ems:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY 